---
title: "æ—¥è¨˜ã‚¢ãƒ—ãƒªã®DBãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–¹æ³•"
emoji: "ğŸ’¾"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [Flutter, Dart]
published: false
---

TODO ãƒªã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã®å®Ÿè£…ã‚’èª¬æ˜ã—ã¾ã™ã€‚

```dart
import 'dart:io';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path_provider/path_provider.dart';

class TodoImporter {
  static final TodoImporter instance = TodoImporter._init();
  static Database? _database;

  TodoImporter._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB();
    return _database!;
  }

  Future<Database> _initDB() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, 'todo.db');

    return await openDatabase(
      path,
      version: 1,
      onCreate: _createDB,
    );
  }

  Future<void> _createDB(Database db, int version) async {
    await db.execute('''
    CREATE TABLE IF NOT EXISTS todos (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT,
      is_completed INTEGER,
      created_at TEXT
    )
    ''');
  }

  // ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  Future<int> importFromTxt(String filePath) async {
    final db = await database;
    final file = File(filePath);
    final content = await file.readAsString();
    final lines = content.split('\n');

    int importCount = 0;
    Map<String, dynamic> todoData = {};

    for (var line in lines) {
      if (line.startsWith('ã‚¿ã‚¹ã‚¯: ')) {
        todoData['title'] = line.substring(5).trim();
      } else if (line.startsWith('çŠ¶æ…‹: ')) {
        todoData['is_completed'] = line.contains('å®Œäº†') ? 1 : 0;
      } else if (line.startsWith('ä½œæˆæ—¥æ™‚: ')) {
        todoData['created_at'] = line.substring(7).trim();

        if (todoData.containsKey('title')) {
          await db.insert('todos', todoData);
          importCount++;
          todoData = {};
        }
      }
    }

    return importCount;
  }

  // CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  Future<int> importFromCsv(String filePath) async {
    final db = await database;
    final file = File(filePath);
    final lines = await file.readAsLines();

    // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
    if (lines.isEmpty || !lines[0].toLowerCase().contains('title')) {
      throw FormatException('ç„¡åŠ¹ãªCSVãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™');
    }

    final headers = lines[0].split(',');
    final titleIndex = headers.indexWhere((h) => h.toLowerCase().contains('title'));
    final completedIndex = headers.indexWhere((h) => h.toLowerCase().contains('completed'));
    final dateIndex = headers.indexWhere((h) => h.toLowerCase().contains('created'));

    int importCount = 0;

    // ãƒ‡ãƒ¼ã‚¿è¡Œã‚’å‡¦ç†
    for (var i = 1; i < lines.length; i++) {
      if (lines[i].trim().isEmpty) continue;

      final values = lines[i].split(',');
      if (values.length >= headers.length) {
        final todo = {
          'title': values[titleIndex].replaceAll('"', '').trim(),
          'is_completed': int.tryParse(values[completedIndex]) ?? 0,
          'created_at': values[dateIndex].replaceAll('"', '').trim(),
        };

        await db.insert('todos', todo);
        importCount++;
      }
    }

    return importCount;
  }

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆå¾©å…ƒï¼‰
  Future<bool> importFromDatabase(String backupPath) async {
    try {
      // ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’é–‰ã˜ã‚‹
      if (_database != null && _database!.isOpen) {
        await _database!.close();
        _database = null;
      }

      final dbPath = await getDatabasesPath();
      final targetPath = join(dbPath, 'todo.db');

      // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
      if (!await File(backupPath).exists()) {
        throw Exception('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }

      // æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’å‰Šé™¤
      await deleteDatabase(targetPath);

      // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒ
      await File(backupPath).copy(targetPath);

      return true;
    } catch (e) {
      print('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å¾©å…ƒã‚¨ãƒ©ãƒ¼: $e');
      return false;
    }
  }

  // ãƒ‡ãƒ¼ã‚¿ç¢ºèªç”¨ã®ãƒ¡ã‚½ãƒƒãƒ‰
  Future<List<Map<String, dynamic>>> getAllTodos() async {
    final db = await database;
    return await db.query('todos', orderBy: 'created_at DESC');
  }
}

// ä½¿ç”¨ä¾‹
void importExample() async {
  final importer = TodoImporter.instance;

  // ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  final docDir = await getApplicationDocumentsDirectory();
  final txtPath = join(docDir.path, 'todos.txt');
  final txtCount = await importer.importFromTxt(txtPath);
  print('ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰$txtCountä»¶ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');

  // CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  final csvPath = join(docDir.path, 'todos.csv');
  final csvCount = await importer.importFromCsv(csvPath);
  print('CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰$csvCountä»¶ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å¾©å…ƒ
  final dbBackupPath = join(docDir.path, 'todo_backup.db');
  final isRestored = await importer.importFromDatabase(dbBackupPath);
  print('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å¾©å…ƒ${isRestored ? 'ã«æˆåŠŸ' : 'ã«å¤±æ•—'}ã—ã¾ã—ãŸ');

  // ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ãŸãƒ‡ãƒ¼ã‚¿ã®ç¢ºèª
  final todos = await importer.getAllTodos();
  for (var todo in todos) {
    print('${todo['title']} - ${todo['is_completed'] == 1 ? 'å®Œäº†' : 'æœªå®Œäº†'}');
  }
}
```

## 2. CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

### å…¥åŠ›å½¢å¼

```csv
id,title,is_completed,created_at
1,"è²·ã„ç‰©ã«è¡Œã",0,2024-01-21T10:00:00
```

### ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†

```dart
// ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’è§£æ
final headers = lines[0].split(',');
final titleIndex = headers.indexWhere((h) => h.toLowerCase().contains('title'));

// ãƒ‡ãƒ¼ã‚¿è¡Œã‚’å‡¦ç†
for (var i = 1; i < lines.length; i++) {
  final values = lines[i].split(',');
  final todo = {
    'title': values[titleIndex].replaceAll('"', '').trim(),
    'is_completed': int.tryParse(values[completedIndex]) ?? 0,
    // ...
  };
}
```

## 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

### å‡¦ç†æ‰‹é †

1. æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’é–‰ã˜ã‚‹
2. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
3. æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’å‰Šé™¤
4. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒ

```dart
// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’é–‰ã˜ã‚‹
if (_database != null && _database!.isOpen) {
  await _database!.close();
  _database = null;
}

// ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒ
final targetPath = join(dbPath, 'todo.db');
await File(backupPath).copy(targetPath);
```

## ä½¿ç”¨æ–¹æ³•

```dart
final importer = TodoImporter.instance;

// ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
final txtCount = await importer.importFromTxt('todos.txt');

// CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
final csvCount = await importer.importFromCsv('todos.csv');

// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å¾©å…ƒ
final isRestored = await importer.importFromDatabase('todo_backup.db');
```

## ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã®æ³¨æ„ç‚¹

1. ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼

```dart
// CSVã®ãƒ˜ãƒƒãƒ€ãƒ¼æ¤œè¨¼
if (lines.isEmpty || !lines[0].toLowerCase().contains('title')) {
  throw FormatException('ç„¡åŠ¹ãªCSVãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™');
}
```

2. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```dart
try {
  // ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†
} catch (e) {
  print('ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: $e');
  return false;
}
```

3. ãƒ‡ãƒ¼ã‚¿ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯

- å¿…è¦ã«å¿œã˜ã¦ã€æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ã¨ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™

ã“ã®å®Ÿè£…ã«ã‚ˆã‚Šã€ã•ã¾ã–ã¾ãªå½¢å¼ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’ç°¡å˜ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã¾ã™ã€‚å½¢å¼ã”ã¨ã«é©åˆ‡ãªãƒ‘ãƒ¼ã‚¹å‡¦ç†ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€ãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§ã‚’ä¿ã¡ãªãŒã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå¯èƒ½ã§ã™ã€‚
