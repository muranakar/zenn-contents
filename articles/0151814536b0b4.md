---
title: "ã€iOSã€‘ã“ã‚Œã¾ã§ã«ä½¿ç”¨ã—ãŸæŠ€è¡“"
emoji: "ğŸ‘¨â€ğŸ’»"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [iOS,Swift,SwiftUI,UIKit]
published: true
---

ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªã§ã™ã€‚ä»¥ä¸‹ã®é †ç•ªã§è¨˜è¼‰ã—ã¾ã™ã€‚

- ãƒªãƒªãƒ¼ã‚¹ã—ãŸã‚¢ãƒ—ãƒªã®æ¦‚è¦
- ä½¿ç”¨ã—ãŸæŠ€è¡“
- ç™ºä¿¡æ´»å‹•

## ãƒªãƒªãƒ¼ã‚¹ã—ãŸã‚¢ãƒ—ãƒªã®æ¦‚è¦

ã“ã‚Œã¾ã§ãƒªãƒªãƒ¼ã‚¹ã—ãŸiOSã‚¢ãƒ—ãƒªã¯

- UIKit 34å€‹
- SwiftUIã€€5å€‹ï¼ˆå†…ã®2ã¤ãŒWatchOSï¼‰
- Unityã€€1å€‹
  
ã®åˆè¨ˆ40å€‹ã®ã‚¢ãƒ—ãƒªã‚’ãƒªãƒªãƒ¼ã‚¹ã—ã¾ã—ãŸã€‚

### æˆæœ

2024/06/22æ™‚ç‚¹ã§ã€åˆè¨ˆç´„12ä¸‡ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ã™ã€‚

iPadã®ãƒ¡ãƒ‡ã‚£ã‚«ãƒ«ã‚«ãƒ†ã‚´ãƒªãƒ¼ã§ï¼“ä½ã«ãªã‚Šã¾ã—ãŸã€‚

![AppStore](/images/2024-07-12-12-48-59.png)

ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ”¯æ´ãƒ„ãƒ¼ãƒ«ï¼ˆç­†è«‡ãƒ»æ–‡å­—ãƒ‘ãƒƒãƒ‰ï¼‰ã‚¢ãƒ—ãƒªã®ãŠã™ã™ã‚ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã§1ä½ã«ãªã‚Šã¾ã—ãŸã€‚ï¼ˆ2024å¹´7æœˆ12æ—¥æ™‚ç‚¹ï¼‰

https://megalodon.jp/2024-0712-1049-24/https://app-liv.jp:443/health/assist/1526/

## ä½¿ç”¨ã—ãŸæŠ€è¡“

å…¨ã¦ã®ã‚¢ãƒ—ãƒªã®ä½¿ç”¨ã—ãŸæŠ€è¡“ã‚’æŒ¯ã‚Šè¿”ã£ã¦ã„ãã¾ã™ã€‚

### FIM:ç”Ÿæ´»ã®è‡ªç«‹åº¦ã‚’è©•ä¾¡ã™ã‚‹

https://apps.apple.com/jp/app/id1606480076

ä¸€äººã²ã¨ã‚Šã®å‹•ä½œãƒ¬ãƒ™ãƒ«ã‚’ã€è©•ä¾¡ã‚’è¡Œã†ãŸã‚ã«ç”¨ã„ã‚‹ãƒ„ãƒ¼ãƒ«

![](https://storage.googleapis.com/zenn-user-upload/1f0407b4083f-20230514.gif =200x)

- `UITableView`ã«ã‚ˆã‚‹ãƒªã‚¹ãƒˆè¡¨ç¤º
- `UITextField`ã«ã‚ˆã‚‹å…¥åŠ›å‡¦ç†
- `NavigationController`ã‚’ç”¨ã„ãŸç”»é¢é·ç§»
- Repositoryãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã®`Realm`ã®CRUDæ“ä½œ
- `QuickLook`ã‚’ç”¨ã„ãŸPDFå‡ºåŠ›
- JSONã‹ã‚‰æ§‹é€ ä½“ã¸ã®å¤‰æ›ï¼ˆ`Decodable`ã‚’ç”¨ã„ã¦ï¼‰
- Lineã€Twitterã¸ã®å…±æœ‰æ©Ÿèƒ½

### å€‹åˆ¥ã‚¿ã‚¤ãƒ æ¸¬å®š:ä¸€äººã²ã¨ã‚Šã®æ™‚é–“ã‚’è¨ˆæ¸¬

https://apps.apple.com/jp/app/id1612725154

ã‚¿ã‚¤ãƒãƒ¼æ©Ÿèƒ½ã‚’ç”¨ã„ãŸã€å‹•ä½œãƒ»æ¤œæŸ»ã‚’ãŠã“ãªã†è©•ä¾¡ãƒ„ãƒ¼ãƒ«

![](https://storage.googleapis.com/zenn-user-upload/9776c5c0e1ca-20230514.gif =200x)

- `QuartzCore`ã‚’ç”¨ã„ãŸã‚¿ã‚¤ãƒãƒ¼å®Ÿè£…ã€‚
â†’ã€€ç”»é¢ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ¬ãƒ¼ãƒˆã«åŒæœŸã•ã›ã‚‹ãŸã‚ã«ã€`CADisplayLink`ã‚’ç”¨ã„ã¦ã‚¿ã‚¤ãƒãƒ¼å®Ÿè£…ã€‚
- ä»Šå›ã®ã‚¢ãƒ—ãƒªã¨ã¯åˆ¥ã§ã€`Timer`ã‚’ç”¨ã„ãŸå®Ÿè£…ã‚’ã‚µãƒ³ãƒ—ãƒ«ã‚¢ãƒ—ãƒªã§å®Ÿè£…ã€‚

### HDS-R:èªçŸ¥ç—‡ã‚’ç°¡å˜ã«æ¤œæŸ»ã™ã‚‹:ç—´å‘†ç—‡ã‚’è©•ä¾¡ã™ã‚‹

https://apps.apple.com/jp/app/id1616574755

èªçŸ¥ç—‡ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°æ¤œæŸ»ã§ç”¨ã„ã‚‹ãƒ„ãƒ¼ãƒ«

![](https://storage.googleapis.com/zenn-user-upload/3ed6d2a9147f-20230514.gif =200x)

- `UIImageView`ã‚’ç”¨ã„ãŸç”»åƒã®è¡¨ç¤º
- `UITapGestureRecognizer`ã‚’ç”¨ã„ãŸã‚¿ãƒƒãƒ—å‡¦ç†
- `UIVisualEffectView()`ã‚’ç”¨ã„ãŸèƒŒæ™¯ã®ã¼ã‹ã—
- `UIViewControllerTransitioningDelegate`ã€`UIViewControllerAnimatedTransitioning`ã«ã‚ˆã‚‹ç”»é¢é·ç§»ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

åŒ»ç™‚ãƒ»ä»‹è­·ã«ã¾ã¤ã‚ã‚‹äº‹æ¥­æ‰€ã‚’æ¢ã™ãŸã‚ã®ãƒãƒƒãƒ—

https://apps.apple.com/jp/app/id1624994936

åŒ»ç™‚ãƒ»ä»‹è­·ã«é–¢é€£ã—ãŸäº‹æ¥­æ‰€ã‚’æ¤œç´¢ã™ã‚‹ãƒ„ãƒ¼ãƒ«ã€‚äº‹æ¥­æ‰€åˆ¥ã«åˆè¨ˆï¼˜å€‹ã®ãƒãƒƒãƒ—ã‚¢ãƒ—ãƒªã‚’ä½œæˆã€‚

![](https://storage.googleapis.com/zenn-user-upload/7a09f7c09de4-20230514.gif =200x)

åšç”ŸåŠ´åƒçœã®åŒ»ç™‚ãƒ»ä»‹è­·ã«ã¾ã¤ã‚ã‚‹äº‹æ¥­æ‰€ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ç”¨ã„ã¦å®Ÿè£…ã€‚

- `MapKit`ãƒ»`Core Location`ã‚’ç”¨ã„ãŸãƒãƒƒãƒ—è¡¨ç¤º
- `PickerViewKeyboardDelegate`ã‚’ç”¨ã„ãŸ`PickerView`ã®åˆ¶å¾¡
- `UIActivityIndicatorView`ã‚’ç”¨ã„ã¦ã€ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã®è¡¨ç¤ºå®Ÿè£…
- `UISegment`ã‚’ç”¨ã„ã¦ã€æ¡ä»¶ã”ã¨ã®æ¤œç´¢çµæœã®è¡¨ç¤º
- `WebKit`ã‚’ã‚‚ã¡ã„ã¦ã€äº‹æ¥­æ‰€ã®è©³ç´°æƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹å®Ÿè£…

### ã‚‚ã˜ã¤ãªã:èªçŸ¥ç—‡ ç™ºé”éšœå®³ã®æ–¹ã®è„³ãƒˆãƒ¬ã‚²ãƒ¼ãƒ 

https://apps.apple.com/jp/app/id1630835450
![](https://storage.googleapis.com/zenn-user-upload/dfc725a295c5-20230514.gif =200x)

- csvãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ§‹é€ ä½“ã¸ãƒ‡ã‚³ãƒ¼ãƒ‰
- `Core Graphics`,,`Core Animation`,`Drawing`ï¼ˆ`UIBezierPath`ï¼‰ãªã©ã‚’ç”¨ã„ã¦æç”»å‡¦ç†

### ã¿ã¤ã‘ã‚‚ã˜:èªçŸ¥ç—‡ ç™ºé”éšœå®³ã®è„³ãƒˆãƒ¬ã‚²ãƒ¼ãƒ 

https://apps.apple.com/jp/app/id1633155568

ä¸Šéƒ¨ã«è¡¨ç¤ºã•ã‚Œã‚‹ä¸€ã¤ã®æ–‡å­—ã‚’ã€ä¸­å¤®éƒ¨åˆ†ã®æ–‡å­—ã®ãƒªã‚¹ãƒˆã‹ã‚‰æ¢ã™è„³ãƒˆãƒ¬ã‚¢ãƒ—ãƒª

![3Ã—3ã®è¡¨ç¤º](https://storage.googleapis.com/zenn-user-upload/59f1dc2a2304-20230514.gif =200x)

![7Ã—7ã®è¡¨ç¤º](https://storage.googleapis.com/zenn-user-upload/077d6f41882f-20230514.gif =200x)

`UICollectionView`ã®å®Ÿè£…

- `UICollectionViewDataSource`ã‚’ç”¨ã„ã¦ã€å€¤ã®è¨­å®š
- `UICollectionViewDelegate`ã‚’ç”¨ã„ã¦ã€ã‚¿ãƒƒãƒ—ã•ã‚ŒãŸéš›ã®å‡¦ç†ã®è¨­å®š
- `UICollectionViewDelegateFlowLayout`ã‚’ç”¨ã„ã¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š

### å£°æ—¥è¨˜ãƒ»è­°äº‹éŒ²ãƒ»è¨ºå¯Ÿãƒ¬ã‚³ãƒ¼ãƒ€ãƒ¼

https://apps.apple.com/jp/app/id1635969637

éŸ³å£°èªè­˜ãƒ»éŒ²éŸ³ãƒ»ãƒ‡ãƒ¼ã‚¿ä¿å­˜ãƒ»ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½ã‚’ç”¨ã„ãŸã€éŸ³å£°ãƒ»æ–‡å­—è¨˜éŒ²ã‚¢ãƒ—ãƒªã€‚

![](https://storage.googleapis.com/zenn-user-upload/4534e7ec0b72-20230514.gif =200x)

- éŒ²éŸ³ãƒœã‚¿ãƒ³ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè£…
- `AVFoundation`(`AVAudioRecorder`ã‚’ç”¨ã„ã¦éŒ²éŸ³)
- `Speech`ã‚’ç”¨ã„ãŸéŸ³å£°èªè­˜
- `NotificationCenter`ã‚’ç”¨ã„ã¦ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é·ç§»ã®æœ‰ç„¡ã®æ¤œå‡º
- `FileManager`ã‚’ç”¨ã„ãŸéŒ²éŸ³ãƒ‡ãƒ¼ã‚¿(.m4a)ã®CRUDå‡¦ç†
- `FSCalendar`ï¼ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ï¼‰ã‚’ç”¨ã„ã¦ã€ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®å®Ÿè£…
- `Calendar`ã‚’ç”¨ã„ãŸæ—¥ä»˜å‡¦ç†
- `AVAudioPlayer`ã‚’ç”¨ã„ãŸã€éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®å†ç”Ÿã€å†ç”Ÿé–‹å§‹æ™‚ç‚¹ã®æŒ‡å®šã€ã‚¹ã‚­ãƒƒãƒ—ã®å®Ÿè£…
- `AVAudioPlayerDelegate`ã‚’ç”¨ã„ãŸã€éŸ³å£°ãƒ‡ãƒ¼ã‚¿å†ç”Ÿçµ‚äº†æ™‚ã®å‡¦ç†
- `UITextViewDelegate`ã‚’ç”¨ã„ãŸã€ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ä¸­ã®ãƒ‡ãƒ¼ã‚¿ä¿å­˜å‡¦ç†

### ã‚³ãƒŸãƒ¥ãƒœãƒ¼ãƒ‰:è€³ãŒé ã„æ–¹ã¨ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ„ãƒ¼ãƒ«

https://apps.apple.com/jp/app/id1638036122

éŸ³å£°èªè­˜æ©Ÿèƒ½ã‚’ç”¨ã„ãŸé›£è´ã®é«˜é½¢è€…ã®æ–¹ã¨ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ—ãƒª

![](https://storage.googleapis.com/zenn-user-upload/e79e61bad081-20230514.gif =200x)

- `Speech`ã‚’ç”¨ã„ãŸéŸ³å£°èªè­˜
- ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºå¯¾å¿œ
- iPhoneã€iPadã®AutoLayoutã§ã®UIèª¿æ•´
- `StoreKit`ã‚’ç”¨ã„ãŸã€ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†
- `ATTrackingManager`ã‚’ç”¨ã„ãŸãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°å®Ÿè£…
- `Admob`ã‚’ç”¨ã„ãŸåºƒå‘Šå®Ÿè£…
- `Firebase Crashlytics`ã‚’ç”¨ã„ãŸã‚¯ãƒ©ãƒƒã‚·ãƒ¥ãƒ­ã‚°ãƒ¬ãƒãƒ¼ãƒˆãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…

### å°åˆ·ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼:ç°¡å˜ã‚·ãƒ³ãƒ—ãƒ«ã«å¹´æœˆãƒ—ãƒªãƒ³ãƒˆã§ãã‚‹

https://apps.apple.com/jp/app/id1639296709

PDFã§æœˆã”ã¨ã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å°åˆ·ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ãƒ„ãƒ¼ãƒ«

![](https://storage.googleapis.com/zenn-user-upload/9024d28afdcb-20230514.gif =200x)

- ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’ä½œæˆã™ã‚‹éš›ã«ã€HTMLãƒ»CSSã®ã‚³ãƒ¼ãƒ‰ã‚’ã€€swiftã§å®Ÿè£…

::: details ã€€ä¾‹

```swift
protocol Builder {
    func build() -> String
}
struct Cell: Builder {
    func build() -> String {
        var content = "<div style=\"font-size: 30px;\">\(day)</div>"
        if let schedule1 = schedule1 {
            content += "<div style=\"font-size: 20px;\">\(schedule1)</div>"
        }
        if let schedule2 = schedule2 {
            content += "<div style=\"font-size: 20px;\">\(schedule2)</div>"
        }
        if let schedule3 = schedule3 {
            content += "<div style=\"font-size: 20px;\">\(schedule3)</div>"
        }

        return "<td>\(content)</td>"
    }
    init(day: Int, weekDay: WeekDay) {
        self.day = day
        self.weekDay = weekDay
        self.schedule1 = nil
        self.schedule2 = nil
        self.schedule3 = nil
    }
    init(day: Int,schedule1: String?,schedule2: String?,schedule3: String?, weekDay: WeekDay) {
        self.day = day
        self.weekDay = weekDay
        self.schedule1 = schedule1
        self.schedule2 = schedule2
        self.schedule3 = schedule3
    }
    init(day: Int,schedule1: String?, weekDay: WeekDay) {
        self.day = day
        self.weekDay = weekDay
        self.schedule1 = schedule1
        self.schedule2 = nil
        self.schedule3 = nil
    }

    var schedule1: String?
    let schedule2: String?
    let schedule3: String?
    let day: Int
    let weekDay: WeekDay
}

struct Row: Builder {
    func build() -> String {
        "<tr height=\"160\">\(cells.map{ $0.build() }.joined())</tr>"
    }
    let cells: [Cell]
}

struct Table: Builder {
    func build() -> String {
        "<table>\(rows.map{ $0.build() }.joined())</table>"
    }
    let rows: [Row]
}
```
:::

- PDFãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
- HTML,CSSã‚’ç”¨ã„ãŸPDFã§ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ä½œæˆ
- `QuickLook`ã‚’ç”¨ã„ãŸPDFã§ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼è¡¨ç¤º

### å®¶æ—çˆ†å¼¾ã‚²ãƒ¼ãƒ -å†™çœŸã‚’ä½¿ã£ã¦,ã¿ã‚“ãªã§ãƒ‰ã‚­ãƒ‰ã‚­

---

https://apps.apple.com/jp/app/id1640584555

é»’ã²ã’å±æ©Ÿä¸€ç™ºã«ä¼¼ãŸä»•æ§˜ã§ã‚ã‚Šã€ãƒã‚ºãƒ¬ãŒä¸€ã¤ç´›ã‚Œã¦ã„ã¦ã€ãƒã‚ºãƒ¬ã‚’æŠ¼ã™ã¨å‹•ç”»ãŒæµã‚Œã‚‹ã‚²ãƒ¼ãƒ ã‚¢ãƒ—ãƒª

![](https://storage.googleapis.com/zenn-user-upload/398d698d9981-20230514.gif =200x)

![](https://storage.googleapis.com/zenn-user-upload/a8402c3bb043-20230514.gif =200x)

- `UIImagePickerController`ã‚’ç”¨ã„ãŸå†™çœŸã®é¸æŠ
- `RSKImageCropper`ï¼ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ï¼‰ã‚’ç”¨ã„ãŸã€å†™çœŸãƒ‡ãƒ¼ã‚¿ã®åˆ‡ã‚Šå–ã‚Š
- `UIGraphicsBeginImageContext`,`UIGraphicsGetCurrentContext`ã‚’ç”¨ã„ãŸæç”»å‡¦ç†
- æç”»å‡¦ç†ã‹ã‚‰ã€ `UIGraphicsGetImageFromCurrentImageContext`ã‚’ç”¨ã„ã¦ç”»åƒã‚’ä½œæˆ
- ç”»åƒãƒ‡ãƒ¼ã‚¿ã®åˆ‡ã‚Šå–ã£ãŸéƒ¨åˆ†ä»¥å¤–ã‚’é€æ˜ã«ã™ã‚‹ãŸã‚ã«ã€pngãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›´

### è„³ãƒˆãƒ¬123:ãƒ©ãƒ³ãƒ€ãƒ è¡¨ç¤º&é›£æ˜“åº¦èª¿æ•´ãŒå¯èƒ½!

https://apps.apple.com/jp/app/id1641708472

ãƒ©ãƒ³ãƒ€ãƒ ã«æ•°å­—ãƒ»ã²ã‚‰ãŒãªãŒè¡¨ç¤ºã•ã‚Œã€é †ç•ªé€šã‚Šã«ã‚¿ãƒƒãƒ—ã—ã¦ã„ãè„³ãƒˆãƒ¬ã‚¢ãƒ—ãƒª

æ•°å­—Version

![](https://storage.googleapis.com/zenn-user-upload/67cf3085f8d8-20230514.gif =200x)

ã²ã‚‰ãŒãªVersion

![](https://storage.googleapis.com/zenn-user-upload/46d924320cf3-20230514.gif =200x)

- ã‚³ãƒ¼ãƒ‰ã§UIButtonã‚’ç”Ÿæˆãƒ»å‰Šé™¤ã®å®Ÿè£…
- ãƒ©ãƒ³ãƒ€ãƒ ã«UIButtonãŒè¡¨ç¤ºã•ã‚Œã‚‹ãŸã‚ã€é‡ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®å®Ÿè£…

::: details ãƒœã‚¿ãƒ³ã®é‡ãªã‚Šã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®ã‚³ãƒ¼ãƒ‰

```swift
struct ButtonPosition {
    var minX: CGFloat
    var maxX: CGFloat
    var minY: CGFloat
    var maxY: CGFloat

    func isOverlap(labelPosition: ButtonPosition) -> Bool {
        let rangeX = minX...maxX
        let rangeY = minY...maxY

        let isOverlapMinX = rangeX.contains(labelPosition.minX)
        let isOverlapMaxX = rangeX.contains(labelPosition.maxX)
        let isOverlapMinY = rangeY.contains(labelPosition.minY)
        let isOverlapMaxY = rangeY.contains(labelPosition.maxY)

        if isOverlapMinX && isOverlapMinY { return true }
        if isOverlapMinX && isOverlapMaxY { return true }
        if isOverlapMaxX && isOverlapMinY { return true }
        if isOverlapMaxX && isOverlapMaxY { return true }
        return false
    }
}
```
:::

- `UIDevice`ã‚’ç”¨ã„ã¦ã€ãƒ‡ãƒã‚¤ã‚¹ã”ã¨ã«è¡¨ç¤ºã™ã‚‹æ–‡å­—ã®æ•°ã‚’å¤‰æ›´ã™ã‚‹å®Ÿè£…

::: details ãƒ‡ãƒã‚¤ã‚¹ã‚’Boolã§åˆ¤å®šã™ã‚‹ãŸã‚ã®ã‚³ãƒ¼ãƒ‰

```swift
struct DeviceType {
    static func isIPhone() -> Bool {
        return UIDevice.current.userInterfaceIdiom == .phone
    }
    static func isIPad() -> Bool {
        return UIDevice.current.userInterfaceIdiom == .pad
    }
}
```
:::

### è„³ãƒˆãƒ¬:ãƒ”ã‚¯ãƒˆã‚°ãƒ©ãƒ ã§æ³¨æ„åŠ›UP!ãƒ©ãƒ³ãƒ€ãƒ è¡¨ç¤º&é›£æ˜“åº¦èª¿æ•´

https://apps.apple.com/jp/app/id1643364510

çœŸã‚“ä¸­ã«è¡¨ç¤ºã•ã‚ŒãŸç”»åƒã¨åŒã˜ç”»åƒã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹è„³ãƒˆãƒ¬ã‚²ãƒ¼ãƒ 
ç”»åƒãŒå›è»¢ã—ã¦ãŠã‚Šã€ãƒ¡ãƒ³ã‚¿ãƒ«ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã«ãªã‚Šã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/e33915aef228-20230514.gif =200x)

- ç”»åƒã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«å›è»¢ã•ã›ã‚‹å®Ÿè£…
  
::: details ã€€ä¾‹

```swift
let randomRotationAngle = CGFloat(Float(Array(1...360).randomElement()!))
newImageView.transform = CGAffineTransform(rotationAngle: randomRotationAngle)
```
:::

### è„³ãƒˆãƒ¬è¨ˆç®—:ã‚·ãƒ³ãƒ—ãƒ«ã§ç°¡å˜ãªæ“ä½œ,æš—ç®—,ç®—æ•°,æ•°å­¦ãƒ‰ãƒªãƒ«

https://apps.apple.com/jp/app/id1644516996

ãƒ©ãƒ³ãƒ€ãƒ ã«æ•°å­—ãŒè¡¨ç¤ºã•ã‚Œã€å¼ãŒæˆã‚Šç«‹ã¤ã‚ˆã†ã«å››å‰‡æ¼”ç®—ã®è¨˜å·ã‚’å…¥ã‚Œã‚‹è„³ãƒˆãƒ¬ã‚²ãƒ¼ãƒ 

![](https://storage.googleapis.com/zenn-user-upload/466a59ce95ed-20230514.gif =200x)

- è¨ˆç®—ã®å®Ÿè£…
  
::: details ã€€ä¾‹

```swift
enum GameModeNumCount {
    case two
    case three
    case four
    case five
}

enum CalculationMethod: CaseIterable {
    case addition
    case subtraction
    case multiplication
    case division

    func textSymbol() -> String {
        switch self {
        case .addition:
            return "+"
        case .subtraction:
            return "-"
        case .multiplication:
            return "*"
        case .division:
            return "/"
        }
    }
    func textName() -> String {
        switch self {
        case .addition:
            return "addition"
        case .subtraction:
            return "subtraction"
        case .multiplication:
            return "multiplication"
        case .division:
            return "division"
        }
    }

}

struct FillBlankCalculation {
    var num1: Int
    var num2: Int
    var num3: Int?
    var num4: Int?
    var num5: Int?
    var result: Double?
    var gameModeNumCount: GameModeNumCount
    var correctAnswerCalculationMethods: [CalculationMethod]
    var answerCalculationMethods: [CalculationMethod]

    init (gameModeNumCount: GameModeNumCount) {
        self.gameModeNumCount = gameModeNumCount
        let randomNumArray = Array(1...9)
        num1 = randomNumArray.randomElement()!
        num2 = randomNumArray.randomElement()!
        switch gameModeNumCount {
        case .two:
            correctAnswerCalculationMethods =
            [CalculationMethod.allCases.randomElement()!]
        case .three:
            num3 = randomNumArray.randomElement()!
            correctAnswerCalculationMethods = [CalculationMethod.allCases.randomElement()!,CalculationMethod.allCases.randomElement()!]
        case .four:
            num3 = randomNumArray.randomElement()!
            num4 = randomNumArray.randomElement()!
            correctAnswerCalculationMethods = [CalculationMethod.allCases.randomElement()!,CalculationMethod.allCases.randomElement()!,CalculationMethod.allCases.randomElement()!]
        case .five:
            num3 = randomNumArray.randomElement()!
            num4 = randomNumArray.randomElement()!
            num5 = randomNumArray.randomElement()!
            correctAnswerCalculationMethods =
            [CalculationMethod.allCases.randomElement()!,
             CalculationMethod.allCases.randomElement()!,
             CalculationMethod.allCases.randomElement()!,
             CalculationMethod.allCases.randomElement()!]
        }
        answerCalculationMethods = []
        result = calculateResult(correctAnswerCalculationMethods)
    }

    mutating func processWhenTheCorrectAnswer() {
        resetAllNumAndResultAndCalculation()
    }
    mutating func processWhenTheInCorrectAnswer() {
        answerCalculationMethods = []
    }

    mutating func resetAllNumAndResultAndCalculation() {
        answerCalculationMethods = []
        correctAnswerCalculationMethods = []
        initializeAllNum()
        initializeCalculationMethods()
        result = calculateResult(correctAnswerCalculationMethods)
    }

    mutating func initializeAllNum() {
        let randomNumArray = Array(1...9)
        num1 = randomNumArray.randomElement()!
        num2 = randomNumArray.randomElement()!
        switch gameModeNumCount {
        case .two:
            break
        case .three:
            num3 = randomNumArray.randomElement()!
        case .four:
            num3 = randomNumArray.randomElement()!
            num4 = randomNumArray.randomElement()!
        case .five:
            num3 = randomNumArray.randomElement()!
            num4 = randomNumArray.randomElement()!
            num5 = randomNumArray.randomElement()!
        }
    }
    func calculateResult(_ calculationMethods: [CalculationMethod]) -> Double {
        var resultText = ""
        switch gameModeNumCount {
        case .two:
            resultText = "\(Double(num1))" + "\(calculationMethods[0].textSymbol())" + "\(Double(num2))"
        case .three:
            resultText = "\(Double(num1))" + "\(calculationMethods[0].textSymbol())" + "\(Double(num2))" + "\(calculationMethods[1].textSymbol())" + "\(Double(num3!))"
        case .four:
            resultText = "\(Double(num1))" + "\(calculationMethods[0].textSymbol())" + "\(Double(num2))" + "\(calculationMethods[1].textSymbol())" + "\(Double(num3!))" + "\(calculationMethods[2].textSymbol())" + "\(Double(num4!))"
        case .five:
            resultText = "\(Double(num1))" + "\(calculationMethods[0].textSymbol())" + "\(Double(num2))" + "\(calculationMethods[1].textSymbol())" + "\(Double(num3!))" + "\(calculationMethods[2].textSymbol())" + "\(Double(num4!))" + "\(calculationMethods[3].textSymbol())" + "\(Double(num5!))"
        }
        let expression = NSExpression(format: resultText)
        let answer = expression.expressionValue(with: nil, context: nil) as! Double
        return answer
    }

    mutating func initializeCalculationMethods() {
        switch gameModeNumCount {
        case .two:
            correctAnswerCalculationMethods =
            [CalculationMethod.allCases.randomElement()!]
        case .three:
            correctAnswerCalculationMethods =
            [CalculationMethod.allCases.randomElement()!,CalculationMethod.allCases.randomElement()!]
        case .four:
            correctAnswerCalculationMethods =
            [CalculationMethod.allCases.randomElement()!,
             CalculationMethod.allCases.randomElement()!,
             CalculationMethod.allCases.randomElement()!]
        case .five:
            correctAnswerCalculationMethods =
            [CalculationMethod.allCases.randomElement()!,
             CalculationMethod.allCases.randomElement()!,
             CalculationMethod.allCases.randomElement()!,
             CalculationMethod.allCases.randomElement()!]
        }
    }

    /// å›ç­”ã™ã‚‹ã¨ãã«ç”¨ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    mutating func answer(calculationMethod: CalculationMethod) {
        answerCalculationMethods.append(calculationMethod)
    }

    func isCorrectTheAnswer() -> Bool {
        let answerResult = calculateResult(answerCalculationMethods)
        if result == answerResult { return true }
            return false
    }
}
```
:::

- GameKitã‚’ç”¨ã„ãŸã€€Game Centerã®å®Ÿè£…
  
::: details ã€€ä¾‹

```swift
struct GameCenter {
    var player: GKLocalPlayer
    func authenticateLocalPlayer() {
        let player = GKLocalPlayer.local
        player.authenticateHandler = { _, error in
            guard error == nil else {
                print(error?.localizedDescription ?? "")
                return
            }
        }
    }
    
    func showLocationTopLeft() {
        GKAccessPoint.shared.isActive = true
        GKAccessPoint.shared.location = .topLeading
    }

    func showLocationBottomLeft() {
        GKAccessPoint.shared.isActive = true
        GKAccessPoint.shared.location = .bottomLeading
    }

    static func hiddenUI() {
        GKAccessPoint.shared.isActive = false
    }

    func sendLeaderboardWithID(score: Int,leaderboardID: String) {
        if GKLocalPlayer.local.isAuthenticated {
            GKLeaderboard.submitScore(
                score,
                context: 0,
                player: GKLocalPlayer.local,
                leaderboardIDs: [leaderboardID]) { error in
                print(error ?? "")
            }
        } else {
            print("GameCenterã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ã¾ã›ã‚“")
        }
    }
}
```
:::

- AVFoundation (AVAudioPlayerãªã©)ã€€ã‚’ç”¨ã„ã¦ã€æ­£è§£æ™‚ã®éŸ³å£°å‡ºåŠ›
  
::: details ã€€ä¾‹

```swift
extension GameViewController: AVAudioPlayerDelegate {
    func playSound(name: String) {
        guard let path = Bundle.main.path(forResource: name, ofType: "mp3") else {
            print("éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return
        }
        do {
            // AVAudioPlayerã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
            audioPlayer = try AVAudioPlayer(contentsOf: URL(fileURLWithPath: path))

            // AVAudioPlayerã®ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã‚’ã‚»ãƒƒãƒˆ
            audioPlayer.delegate = self

            audioPlayer.prepareToPlay()
            if audioPlayer.isPlaying {
                        audioPlayer.stop()
                        audioPlayer.currentTime = 0
            }
            // éŸ³å£°ã®å†ç”Ÿ
            audioPlayer.play()
        } catch {
        }
    }
}
```
:::

### è¨˜æ†¶åŠ›ã«ç‰¹åŒ–ã—ãŸè„³ãƒˆãƒ¬

---

https://apps.apple.com/jp/app/id6443709224

è¨˜æ†¶åŠ›ã«ç‰¹åŒ–ã—ãŸè„³ãƒˆãƒ¬-ã‚·ãƒ³ãƒ—ãƒ«ã§ç°¡å˜ã«ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°

![](https://storage.googleapis.com/zenn-user-upload/7538f303793e-20230514.gif =200x)

- ç”»åƒã€€ã¨ã€€è‰²ã‚’ç”¨ã„ãŸã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã€CustomViewã‚’ä½œæˆï¼ˆMagicNumberãŒå¤šã„ã¨ã„ã†åçœç‚¹ãŒã‚ã‚Šã¾ã™ï¼‰
  
::: details ã€€ä¾‹

```swift
enum ShapesAll {
    static let allUIColor: [UIColor] = [.blue,.darkGray,.magenta,.brown,.cyan,.green,.lightGray,.orange,.purple,.red,.systemIndigo]
    static let allColorAndColorTextDictionary: [UIColor: String] =
    [.blue: "blue",.darkGray: "darkGray",.magenta: "magenta",.brown:"brown",.cyan:"cyan",.green:"green",.lightGray:"lightGray",.orange:"orange",.purple:"purple",.red:"red",.systemIndigo:"systemIndigo"]

    static let allImageName: [String] = ["circle","circle.fill","square","square.fill","app","app.fill","rectangle","rectangle.fill","rectangle.portrait","rectangle.portrait.fill","capsule","capsule.fill","capsule.portrait","capsule.portrait.fill","oval","oval.fill","oval.portrait","oval.portrait.fill","triangle","triangle.fill","diamond","diamond.fill","octagon","octagon.fill","hexagon","hexagon.fill","pentagon","pentagon.fill","seal","seal.fill","rhombus","rhombus.fill","shield","shield.fill","rectangle.roundedtop","rectangle.roundedtop.fill","rectangle.roundedbottom","rectangle.roundedbottom.fill"]

    static func randomUIColor() -> UIColor {
        return allUIColor.randomElement()!
    }

    static func randomImageName() -> String {
        return allImageName.randomElement()!
    }
}

struct Shape {
    let color: UIColor
    let colorText: String
    let imageName: String
    init() {
        self.color = ShapesAll.randomUIColor()
        self.colorText = ShapesAll.allColorAndColorTextDictionary[color]!
        self.imageName = ShapesAll.randomImageName()
    }
}

class CustomImageView: UIImageView {
    let shape: Shape = Shape()
    let width = 60
    let height = 60

    override init(frame: CGRect) {
        super.init(frame: frame)
        setup()
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    func setup() {
        self.frame.size = .init(width: width, height: height) // ä½ç½®ã¨ã‚µã‚¤ã‚ºã®æŒ‡å®š
        self.tintColor = shape.color
        self.image = UIImage(systemName: shape.imageName)
        self.isUserInteractionEnabled = true
    }

    func isSameShape(customImageView: CustomImageView) -> Bool {
        if self.shape.color == customImageView.shape.color &&
            self.shape.imageName == customImageView.shape.imageName {
            return true
        }
        return false
    }
}

struct ImageViewPosition {
    var minX: CGFloat
    var maxX: CGFloat
    var minY: CGFloat
    var maxY: CGFloat

    func isOverlap(imageViewPosition: ImageViewPosition) -> Bool {
        let rangeX = minX...maxX
        let rangeY = minY...maxY

        let isOverlapMinX = rangeX.contains(imageViewPosition.minX)
        let isOverlapMaxX = rangeX.contains(imageViewPosition.maxX)
        let isOverlapMinY = rangeY.contains(imageViewPosition.minY)
        let isOverlapMaxY = rangeY.contains(imageViewPosition.maxY)

        if isOverlapMinX && isOverlapMinY { return true }
        if isOverlapMinX && isOverlapMaxY { return true }
        if isOverlapMaxX && isOverlapMinY { return true }
        if isOverlapMaxX && isOverlapMaxY { return true }
        return false
    }
}

struct ShapeGame {
    let defaultNumber: [Int]
    var problemSampleImageViewNumber: Int
    let imageViewWidthAndHeight: Int
    var problemRangeX: ClosedRange<CGFloat>
    var problemRangeY: ClosedRange<CGFloat>
    var answerRangeX: ClosedRange<CGFloat>
    var answerRangeY: ClosedRange<CGFloat>

    var answerRandomImageViewPosition: [ImageViewPosition] = []
    var answerRandomCustomImageView: [CustomImageView] = []
    var problemRandomImageViewPosition: [ImageViewPosition] = []
    var problemRandomCustomImageView: [CustomImageView] = []


    mutating func reset() {
        answerRandomImageViewPosition = []
        answerRandomCustomImageView = []
        problemRandomImageViewPosition = []
        problemRandomCustomImageView = []

        configureAnswerRandomImageViewPosition()
        configureAnswerRandomCustomImageView()
        configureProblemRandomImageViewPosition()
        configureProblemRandomCustomImageView()
    }
    mutating func resetAnswerRandomImageViewPosition() {
        answerRandomImageViewPosition = []
        configureAnswerRandomImageViewPosition()
        for i in 1...answerRandomImageViewPosition.count {
            let index: Int = i - 1
            answerRandomCustomImageView[index].frame = CGRect(
                x: Int(answerRandomImageViewPosition[index].minX),
                y: Int(answerRandomImageViewPosition[index].minY),
                width: imageViewWidthAndHeight,
                height: imageViewWidthAndHeight
            )
        }
    }


    mutating func configureAnswerRandomImageViewPosition() {
        for i in defaultNumber {
            while answerRandomImageViewPosition.count < i {
                let randomValueX = CGFloat.random(in: answerRangeX)
                let randomValueY = CGFloat.random(in: answerRangeY)
                let newImageViewPosition = ImageViewPosition(
                    minX: randomValueX,
                    maxX: randomValueX + CGFloat(imageViewWidthAndHeight),
                    minY: randomValueY,
                    maxY: randomValueY + CGFloat(imageViewWidthAndHeight)
                )
                let boolArray = answerRandomImageViewPosition.compactMap { imageViewPosition in
                    return imageViewPosition.isOverlap(imageViewPosition: newImageViewPosition)
                }
                if boolArray.contains(true) {
                    continue
                }
                answerRandomImageViewPosition.append(newImageViewPosition)
            }
        }
    }

    mutating func configureAnswerRandomCustomImageView() {
        for i in Array(1...answerRandomImageViewPosition.count) {
            let index: Int = i - 1
            let customImageView = CustomImageView(
                frame: CGRect(
                    x: Int(answerRandomImageViewPosition[index].minX),
                    y: Int(answerRandomImageViewPosition[index].minY),
                    width: imageViewWidthAndHeight,
                    height: imageViewWidthAndHeight
                )
            )
            answerRandomCustomImageView.append(customImageView)
        }
    }

    mutating func configureProblemRandomImageViewPosition() {
        let problemSampleImageViewArrayIndex = Array(0...problemSampleImageViewNumber - 1)
        for i in problemSampleImageViewArrayIndex {
            while problemRandomImageViewPosition.count - 1 < i {
                let randomValueX = CGFloat.random(in: problemRangeX)
                let randomValueY = CGFloat.random(in: problemRangeY)
                let newImageViewPosition = ImageViewPosition(
                    minX: randomValueX,
                    maxX: randomValueX + CGFloat(imageViewWidthAndHeight),
                    minY: randomValueY,
                    maxY: randomValueY + CGFloat(imageViewWidthAndHeight)
                )
                let boolArray = problemRandomImageViewPosition.compactMap { imageViewPosition in
                    return imageViewPosition.isOverlap(imageViewPosition: newImageViewPosition)
                }
                if boolArray.contains(true) {
                    continue
                }
                problemRandomImageViewPosition.append(newImageViewPosition)
            }
        }
    }

    mutating func configureProblemRandomCustomImageView() {
        problemRandomCustomImageView = Array( answerRandomCustomImageView.prefix(problemSampleImageViewNumber))
        var index = 0
        let newProblemRandomCustomImageView = problemRandomCustomImageView.map { customImageview in
            customImageview.frame = CGRect(
                x: Int(problemRandomImageViewPosition[index].minX),
                y: Int(problemRandomImageViewPosition[index].minY),
                width: imageViewWidthAndHeight,
                height: imageViewWidthAndHeight
            )
            index += 1
            return customImageview
        }
        problemRandomCustomImageView = newProblemRandomCustomImageView
    }

}
```
:::

### æ›œæ—¥ãƒ»å¹²æ”¯ãƒ»å±±æ‰‹ç·šã‚’ç”¨ã„ãŸè„³ãƒˆãƒ¬ã‚¯ã‚¤ã‚º

https://apps.apple.com/jp/app/id6443908223

https://apps.apple.com/jp/app/id6443928188

https://apps.apple.com/jp/app/id6443969703

æ›œæ—¥ãƒ»å¹²æ”¯ãƒ»å±±æ‰‹ç·šã‚’ç”¨ã„ãŸè„³ãƒˆãƒ¬ã‚¯ã‚¤ã‚º

![](https://storage.googleapis.com/zenn-user-upload/00d787c7af52-20230514.gif =200x)

- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…ã€€ã€€æ›œæ—¥version
  
::: details ã€€ä¾‹

```swift
//æ›œæ—¥
enum DayOfTheWeek: Int, Equatable {
    case sunday = 1
    case monday = 2
    case tuesday = 3
    case wednesday = 4
    case thursday = 5
    case friday = 6
    case saturday = 7

    func textJapanese() -> String {
        switch self {
        case .sunday:
            return "æ—¥"
        case .monday:
            return "æœˆ"
        case .tuesday:
            return "ç«"
        case .wednesday:
            return "æ°´"
        case .thursday:
            return "æœ¨"
        case .friday:
            return  "é‡‘"
        case .saturday:
            return  "åœŸ"
        }
    }

    //æ›œæ—¥ã®åˆ¤å®š
    static func set(for date: Date) -> Self {
        let calendar = Calendar(identifier: .gregorian)
        let weekdayNumber = calendar.component(.weekday, from: date)
        let weekDay = DayOfTheWeek(rawValue: weekdayNumber)!
        return weekDay
    }
}

//Quizç”¨ã®ã‚¤ãƒ‹ã‚·ãƒ£ãƒ©ã‚¤ã‚¶
extension DayOfTheWeek {
    init?(quizValue: Int) {
    // 7ã§å‰²ã‚Šãã‚ŒãŸä½™ã‚Šã«ã‚ˆã£ã¦åˆ¤å®š
        var quizValue = quizValue % 7 
        if quizValue == 0 {
            quizValue = 7
        }
//ãƒã‚¤ãƒŠã‚¹ã ã£ãŸã‚‰ï¼‘é€±é–“åˆ†ã«é€²ã‚ã¦æ›œæ—¥ã‚’æ±ºå®š
        if quizValue < 0 { 
            quizValue = quizValue + 7
        }

        self.init(rawValue: quizValue)
    }
}

//Quizã®ãƒ¬ãƒ™ãƒ«
enum QuizLevel {
    case hard
    case normal
    case easy
}

enum DateTextFromNum {
    case dateAfter(dateNum: Int)
    case dateBefore(dateNum: Int)

    init(dateNum: Int) {
        if dateNum > 0 {
            self = .dateAfter(dateNum: dateNum)
        } else if dateNum < 0{
            self = .dateBefore(dateNum: dateNum)
        } else {
            fatalError("DateTextFromNumã«ã€å¼•æ•°ã«èª¤ã‚ŠãŒã‚ã‚Šã¾ã™ã€‚")
        }
    }

    func text() -> String {
        switch self {
        case .dateAfter(dateNum: 2):
            return "æ˜å¾Œæ—¥"
        case .dateAfter(dateNum: 1):
            return "æ˜æ—¥"
        case .dateBefore(dateNum: -1):
            return "æ˜¨æ—¥"
        case .dateBefore(dateNum: -2):
            return "ä¸€æ˜¨æ—¥"
        case .dateAfter(dateNum: let dateNum):
            return "\(dateNum)æ—¥å¾Œ"
        case .dateBefore(dateNum: let dateNum):
            return "\(abs(dateNum))æ—¥å‰"
        }
    }
}

struct Quiz {
    private let level: QuizLevel
    private let today = Date()

    private let firstDateNumber: Int
    private let secondDateNumber: Int
    private let thirdDateNumber: Int

    var text: String {
        let firstText = DateTextFromNum(dateNum: firstDateNumber).text()
        let secondText = DateTextFromNum(dateNum: secondDateNumber).text()
        let thirdText = DateTextFromNum(dateNum: thirdDateNumber).text()

        let totalText: String
        switch level {
        case .hard: totalText = "ä»Šæ—¥ã®\(firstText)ã®\n\(secondText)ã®\n\(thirdText)ã¯ã€\nä½•æ›œæ—¥ï¼Ÿ"
        case .normal: totalText = "ä»Šæ—¥ã®\(firstText)ã®\n\(secondText)ã¯ã€\nä½•æ›œæ—¥ï¼Ÿ"
        case .easy: totalText = "ä»Šæ—¥ã®\(firstText)ã¯ã€\nä½•æ›œæ—¥ï¼Ÿ"
        }

        return totalText
    }

    init(level: QuizLevel) {
        self.level = level
        var randomNumber: Int {
            Array(-7...7)
                .filter{ $0 != 0 }
                .randomElement()!
        }

        firstDateNumber = randomNumber
        secondDateNumber = randomNumber
        thirdDateNumber = randomNumber
    }

    //Testç”¨
    init(first: Int, second: Int, third: Int, level : QuizLevel) {
        firstDateNumber = first
        secondDateNumber = second
        thirdDateNumber = third
        self.level = level
    }

    func answer() -> DayOfTheWeek {
        let weekDay = DayOfTheWeek.set(for: today)

        // ä»Šæ—¥ã®æ›œæ—¥ã«å„ã‚¯ã‚¤ã‚ºã®æ—¥æ•°ã‚’åˆç®—
        let weekDayNumber: Int
        switch level {
        case .hard:
            weekDayNumber = weekDay.rawValue + firstDateNumber + secondDateNumber + thirdDateNumber
        case .normal:
            weekDayNumber = weekDay.rawValue + firstDateNumber + secondDateNumber
        case .easy:
            weekDayNumber = weekDay.rawValue + firstDateNumber
        }
        return DayOfTheWeek(quizValue: weekDayNumber)!
    }
}

struct WeekDayGame {
    private var quiz: Quiz
    let quizLevel: QuizLevel
    var correctCount: Int = 0
    var missCount: Int = 0


    init(level: QuizLevel) {
        quiz = Quiz(level: level)
        quizLevel = level
    }

    init(testQuiz: Quiz,level: QuizLevel) {
        quiz = testQuiz
        quizLevel = level
    }

    func displayQuizText() -> String {
        quiz.text
    }

    mutating func reset() {
        self.quiz = Quiz(level: quizLevel)
    }

    mutating func answer(input: DayOfTheWeek) -> Bool {
        let answer = quiz.answer()
        if answer == input {
            self.correctCount += 1
        } else {
            self.missCount += 1
        }
        return answer == input ? true : false
    }
    func answer() -> DayOfTheWeek{
        return quiz.answer()
    }
}
```
:::

### æ•°å­—ã‚’ç”¨ã„ãŸè¨˜æ†¶åŠ›ã‚’é›ãˆã‚‹è„³ãƒˆãƒ¬

https://apps.apple.com/jp/app/id6444015375

ç”»é¢ã«ãƒ©ãƒ³ãƒ€ãƒ ã«è¡¨ç¤ºã•ã‚ŒãŸæ•°å­—ã‚’ä¸€åº¦è¨˜æ†¶ã—ã¾ã™ã€‚ãã®å¾Œå›ç­”ã™ã‚‹éš›ã«ã©ã®ä½ç½®ã«ã©ã®æ•°å­—ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ãŸã‹ã‚’å›ç­”ã™ã‚‹è„³ãƒˆãƒ¬ã‚²ãƒ¼ãƒ 

![](https://storage.googleapis.com/zenn-user-upload/ca1aa5dae03a-20230514.gif =200x)

- UIBottonã‹ã‚‰ã€CustomButtonã‚’ä½œæˆã—ã¦å®Ÿè£…
  
::: details ã€€ä¾‹

```swift
class CustomButton: UIButton {
    let width = 60
    let height = 60
    var showedNumber: Int?

    override init(frame: CGRect) {
        super.init(frame: frame)
        setup()
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    func setup() {
        self.frame.size = .init(width: width, height: height) // ä½ç½®ã¨ã‚µã‚¤ã‚ºã®æŒ‡å®š
        self.isUserInteractionEnabled = true
    }
}
```
:::

- ç•°ãªã‚‹Buttonã®ä½ç½®ãŒé‡ãªã£ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®šã™ã‚‹å®Ÿè£…

::: details ã€€ä¾‹

```swift
struct ButtonPosition {
    var minX: CGFloat
    var maxX: CGFloat
    var minY: CGFloat
    var maxY: CGFloat

    func isOverlap(buttonPosition: ButtonPosition) -> Bool {
        let rangeX = minX...maxX
        let rangeY = minY...maxY

        let isOverlapMinX = rangeX.contains(buttonPosition.minX)
        let isOverlapMaxX = rangeX.contains(buttonPosition.maxX)
        let isOverlapMinY = rangeY.contains(buttonPosition.minY)
        let isOverlapMaxY = rangeY.contains(buttonPosition.maxY)

        if isOverlapMinX && isOverlapMinY { return true }
        if isOverlapMinX && isOverlapMaxY { return true }
        if isOverlapMaxX && isOverlapMinY { return true }
        if isOverlapMaxX && isOverlapMaxY { return true }
        return false
    }
}
```
:::

### è„³ãƒˆãƒ¬123:å‹•ãæ•°å­—ã‚’ã‚¿ãƒƒãƒ—!ãƒ©ãƒ³ãƒ€ãƒ è¡¨ç¤º!é«˜é½¢è€…å‘ã‘

https://apps.apple.com/jp/app/id1661849645

ãƒ©ãƒ³ãƒ€ãƒ ã«å‹•ã„ã¦ã„ã‚‹æ•°å­—ã‚’é †ç•ªé€šã‚Šã«ã‚¿ãƒƒãƒ—ã™ã‚‹è„³ãƒˆãƒ¬

![](https://storage.googleapis.com/zenn-user-upload/f94e10391da1-20230514.gif =200x)

Unityã€C#ã‚’ç”¨ã„ã¦ä½œæˆã—ãŸã‚¢ãƒ—ãƒªã§ã™ã€‚Unityã‚’ç”¨ã„ãŸç†ç”±ã¯ã€ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³ã‚’ç”¨ã„ã¦å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€Unityã®æ–¹ãŒå®Ÿè£…ã‚³ã‚¹ãƒˆãŒä½ã„ãŸã‚ã§ã™ã€‚ã¾ãŸã€Unityã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã—ãŸã„æ°—æŒã¡ã‚‚ã‚ã‚Šã€é–‹ç™ºã«å–ã‚Šæ›ã‹ã‚Šã¾ã—ãŸã€‚Unityã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã§ã¯ã€ãƒ–ãƒ­ãƒƒã‚¯å´©ã—ãƒ»è„±å‡ºã‚²ãƒ¼ãƒ ã‚‚å®Ÿè£…ã—ã¾ã—ãŸã€‚Unityã‚’ç”¨ã„ãŸå®Ÿè£…ã¯ã€Gameç©ºé–“ã®ä¸­ã®ä¸€ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã€C#ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆè¨­å®šã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆ¶å¾¡ã‚’è¡Œã†éƒ¨åˆ†ã«é¢ç™½ã•ã‚’æ„Ÿã˜ã¾ã—ãŸã€‚ã§ã™ãŒã€UIKitã¨æ¯”ã¹ã‚‹ã¨GUIæ“ä½œãŒå¤šãã€UIKitã¯ã‚³ãƒ¼ãƒ‰ç®¡ç†å¯èƒ½ãªéƒ¨åˆ†ãŒå¤šã„ãŸã‚ã€å€‹äººçš„ã«å®Ÿè£…ã—ã‚„ã™ã‹ã£ãŸãŸã‚ã€ã“ã®ï¼‘ä½œã®ã¿ã¨ã—ã¾ã—ãŸã€‚

### ç›®æ¨™è¨­å®šã‚¢ãƒ—ãƒª

https://apps.apple.com/jp/app/id1664607879

å…¥åŠ›ã—ãŸç›®æ¨™ã‚’PDFå‡ºåŠ›ã—ã€ç´™ã§å°åˆ·ã™ã‚‹ã‚¢ãƒ—ãƒª

![](https://storage.googleapis.com/zenn-user-upload/78768c064b15-20230514.gif =200x)

- PDFã§ã€€æ–‡ç« ã‚’å‡ºåŠ›ã®å®Ÿè£…

::: details ã€€ä¾‹

```swift
final class PDF {
    private let goalFontSize: Int
    private let toDoFontSize: Int
    private let goalTexts: [String]
    private let toDoTexts: [String]
    private let space: Int
    init(
        goalFontSize: Int,
        toDoFontSize: Int,
        goalText: String,
        toDoText: String,
        space: Int
    ) {
        self.goalFontSize = goalFontSize
        self.toDoFontSize = toDoFontSize
        let goalArray = goalText.split(whereSeparator: \.isNewline).map { String($0) }
        self.goalTexts = goalArray
        let toDoArray = toDoText.split(whereSeparator: \.isNewline).map { String($0) }
        self.toDoTexts = toDoArray
        self.space = space
    }
    
    private func getPDF() -> NSData {
        let renderer = UIPrintPageRenderer()
        let verticalPaperSize = CGSize(width: 595.2, height: 841.8)
        let paperFrame = CGRect(origin: .zero, size: verticalPaperSize)
        renderer.setValue(paperFrame, forKey: "paperRect")
        renderer.setValue(paperFrame, forKey: "printableRect")
        let formatter = UIMarkupTextPrintFormatter(markupText: makeHTMLString())
        renderer.addPrintFormatter(formatter, startingAtPageAt: 0)
        let pdfData = NSMutableData()
        UIGraphicsBeginPDFContextToData(pdfData, .zero, [:])
        for pageI in 0..<renderer.numberOfPages {
            UIGraphicsBeginPDFPage()
            renderer.drawPage(at: pageI, in: UIGraphicsGetPDFContextBounds())
        }
        UIGraphicsEndPDFContext()
        return pdfData
    }
    
    func saveToTempDirectory() -> URL? {
        let tempDirectory = NSURL.fileURL(withPath: NSTemporaryDirectory(), isDirectory: true)
        let fileName = "GoalToDo" + ".pdf"
        let filePath = tempDirectory.appendingPathComponent(fileName)
        do {
            try getPDF().write(to: filePath)
            return filePath
        } catch {
            print(error.localizedDescription)
            return nil
        }
    }
    // swiftlint:disable:next function_body_length
    private func makeHTMLString() -> String {
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <title></title>
            <style>
                table,
                th,
                tr,
                td {
                    table-layout: fixed;
                    text-align: left;
                    vertical-align: top;
                    width: 100%;
                    border: 1px solid black;
                    border-collapse: collapse;
                    margin: 0%;
                }
            </style>
        <body>
            <div id="YCalTbl" style="font-size: 50px;padding: \(space)px" class="calleft">
                <div><span style="font-size: 50px;"></span></div>
                <table border="1" cellpadding="10" cellspacing="0">
                    <tbody>
                \(changeGoalTextHTML())
                \(changeToDoTextHTML())
                    </tbody>
                </table>
            </div>
        </body>
        </html>

        """
    }

    func changeGoalTextHTML() -> String {
        var totaltext = ""
        goalTexts.forEach { goalText in
            totaltext +=
            """
            <div><span style="font-size: \(goalFontSize)px;">\(goalText)</span></div>
            """
        }
        totaltext += "<br>"
        return totaltext
    }
    func changeToDoTextHTML() -> String {
        var totaltext = ""
        toDoTexts.forEach { toDoText in
            totaltext +=
            """
            <div><span style="font-size: \(toDoFontSize)px;">\(toDoText)</span></div>
            """
        }
        return totaltext
    }
}
```
:::

### ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼

https://apps.apple.com/jp/app/%E3%82%AB%E3%82%A6%E3%83%B3%E3%82%BF%E3%83%BC/id1669979381

ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨æ•°å­—ã‚’ã‚«ã‚¦ãƒ³ãƒˆã§ãã‚‹ã‚¢ãƒ—ãƒª

![](https://storage.googleapis.com/zenn-user-upload/6492a372c0a4-20230514.gif =200x)

- ã‚«ã‚¦ãƒ³ãƒˆã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…
- Countã®å±¥æ­´ã‚’Realmã§CRUDã€€ï¼ˆRepositoryãƒ‘ã‚¿ãƒ¼ãƒ³ã§å®Ÿè£…ï¼‰
  
::: details ã€€ä¾‹

```swift
final class CountHistoryRepasitory {
    private let realm = try! Realm()
    //ã€€ä¸¦ã³æ›¿ãˆã‚ã‚Š
    func loadCountHistoryAndRemoveMoreThan300(ascending: Bool) -> [CountHistory] {
        let realmCountHistorys = realm
            .objects(RealmCountHistory.self)
            .sorted(byKeyPath: "createdAt",ascending: ascending)
        let realmCountHistorysArray = Array(realmCountHistorys)
        let countHistorys = realmCountHistorysArray.map {CountHistory(managedObject: $0) }
        // å…ˆé ­ã®300å€‹ä»¥å¤–å‰Šé™¤
        Array(countHistorys.dropFirst(300)).forEach { countHistory in
            removeCountHistory(countHistory: countHistory)
        }
        let first100CountHistorys = Array(countHistorys.prefix(300))
        return first100CountHistorys
    }
    func apppendCountHistory(countHistory: CountHistory) {
        try! realm.write {
            let realmCountHistory = countHistory.managedObject()
            realm.add(realmCountHistory)
        }
    }

    func removeCountHistory(countHistory: CountHistory) {
        guard let countHistory = realm.object(
            ofType: RealmCountHistory.self,
            forPrimaryKey: countHistory.uuidString
        ) else { return }
        // swiftlint:disable:next force_cast
        try! realm.write {
            realm.delete(countHistory)
        }
    }
}

struct CountHistory {
    var uuidString = UUID().uuidString
    var countValue: Int
    var createdAt: Date = Date()
    var uuid: UUID? {
        UUID(uuidString: uuidString)
    }
}

class RealmCountHistory: Object {
    @Persisted(primaryKey: true)
    var uuidString = ""
    @Persisted
    var countValue: Int
    @Persisted
    var createdAt: Date
    var uuid: UUID? {
        UUID(uuidString: uuidString)
    }
    convenience init(countValue: Int,createdAt: Date) {
        self.init()
        self.countValue = countValue
        self.createdAt = createdAt
    }
}

private extension CountHistory {
    init(managedObject: RealmCountHistory) {
        self.uuidString = managedObject.uuidString
        self.countValue = managedObject.countValue
        self.createdAt = managedObject.createdAt
    }

    func managedObject() -> RealmCountHistory {
        let realmCountHistory = RealmCountHistory()
        realmCountHistory.uuidString = self.uuidString
        realmCountHistory.countValue = self.countValue
        realmCountHistory.createdAt = self.createdAt
        return realmCountHistory
    }
}
```
:::

- ã‚«ã‚¦ãƒ³ãƒˆãŒè¨­å®šã—ãŸé”æˆå€¤ã«åˆ°é”ã—ãŸã‚‰ã€éŸ³ãŒãªã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ã€é”æˆå€¤ã‚’Realmã§CRUD

::: details ã€€ä¾‹

```swift
final class AchievementRepasitory {
    private let realm = try! Realm()
    //ã€€ä¸¦ã³æ›¿ãˆã‚ã‚Š
    func loadAchievement(ascending: Bool) -> [Achievement] {
        let realmAchievements = realm
            .objects(RealmAchievement.self)
            .sorted(byKeyPath: "value", ascending: ascending)
        let realmAchievementsArray = Array(realmAchievements)
        let achievements = realmAchievementsArray.map {Achievement(managedObject: $0) }
        return achievements
    }

    func apppendAchievement(achievement: Achievement) {
        try! realm.write {
            let realmAchievement = achievement.managedObject()
            realm.add(realmAchievement)
        }
    }

    func removeAchievement(achievement: Achievement) {
        guard let achievement = realm.object(
            ofType: RealmAchievement.self,
            forPrimaryKey: achievement.uuidString
        ) else { return }
        // swiftlint:disable:next force_cast
        try! realm.write {
            realm.delete(achievement)
        }
    }
}

struct Achievement {
    var uuidString = UUID().uuidString
    var value: Int
    var uuid: UUID? {
        UUID(uuidString: uuidString)
    }
}

class RealmAchievement: Object {
    @Persisted(primaryKey: true)
    var uuidString = ""
    @Persisted
    var value: Int

    var uuid: UUID? {
        UUID(uuidString: uuidString)
    }
    convenience init(value: Int) {
        self.init()
        self.value = value
    }
}

private extension Achievement {
    init(managedObject: RealmAchievement) {
        self.uuidString = managedObject.uuidString
        self.value = managedObject.value
    }

    func managedObject() -> RealmAchievement {
        let realmAchievement = RealmAchievement()
        realmAchievement.uuidString = self.uuidString
        realmAchievement.value = self.value
        return realmAchievement
    }
}
```
:::

### ç­‹ãƒˆãƒ¬ã‚¿ã‚¤ãƒãƒ¼

https://apps.apple.com/jp/app/%E3%82%BF%E3%82%A4%E3%83%9E%E3%83%BC-%E7%AD%8B%E3%83%88%E3%83%AC/id6446249318

ç­‹ãƒˆãƒ¬ãƒ»ã‚¹ãƒˆãƒ¬ãƒƒãƒæ™‚ã«ç”¨ã„ã‚‹ã‚¢ãƒ—ãƒª
ã‚«ã‚¦ãƒ³ãƒˆã®é–“éš”ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒå¯èƒ½ã§ã‚ã‚Šã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ—ãƒ©ãƒ³ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç”¨æ„ã—ã¦ã„ã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/677bc1cd55c9-20230514.gif =200x)

![](https://storage.googleapis.com/zenn-user-upload/4eb7e236f9ae-20230514.gif =200x)

- MBCircularProgressBarï¼ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ï¼‰ã‚’ç”¨ã„ã¦ProgressBarã®å®Ÿè£…
- Realmã®åˆæœŸå€¤è¿½åŠ ã®å‡¦ç†
- Timerã®ãƒ­ã‚¸ãƒƒã‚¯ã€€ã€Timerç”¨ã®ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã‚’ä½œæˆã—ã¦ã€‘ï¼ˆå¤šã„ãŸã‚ä¸€éƒ¨ã®ã¿ï¼‰
â†’ä¼‘æ†©ãƒ»ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã€èª­ã¿ä¸Šã’ãƒ»éŸ³å£°å‡ºåŠ›ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸãŸã‚ã€ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã‚’ç”¨ã„ã¦å‡¦ç†ã‚’åˆ†ã‘ãŸã€‚

::: details ã€€ä¾‹

```swift
import Foundation
enum TimerMode {
    case notRunning
    case running
    case continueRunning
    case pausing
}

class CountDownTimer {
    var delegate: CountDownTimerDelegate!

    enum TraningType {
        case training
        case rest
        case restBetweenSets
        case preparation
    }

    var isPause: Bool {
        switch timerMode {
        case .notRunning,.running, .continueRunning:
            return false
        case .pausing:
            return true
        }
    }
    var isRunning: Bool {
            switch timerMode {
            case .running,.continueRunning:
                return true
            case .notRunning, .pausing:
                return false
            }
        }

    var isContinueRunning: Bool {
        switch timerMode {
        case .notRunning,.running, .pausing:
            return false
        case .continueRunning:
            return true
        }
    }

    var trainigModeText: String {
        switch trainigMode {
        case .training:
            return NSLocalizedString("training", comment: "")
        case .rest:
            return NSLocalizedString("rest", comment: "")
        case .restBetweenSets:
            return NSLocalizedString("restBetweenSets", comment: "")
        case .preparation:
            return NSLocalizedString("preparation", comment: "")
        }
    }
    ---
    çœç•¥
    ---

    func start() {
        print("ã‚¹ã‚¿ãƒ¼ãƒˆ")
        timerMode = .running
        delegate?.functionAllWhenStartTimerMode()
        startPreparation()
    }

    func continueRunning() {
        print("å†é–‹")
        timerMode = .continueRunning
        delegate?.functionAllWhenStartTimerMode()
        isImmediatelyAfterContinueRunning = true
        switch trainigMode {
        case .training:
            startTraning()
        case .rest:
            startRest()
        case .restBetweenSets:
            startRestBetweenSets()
        case .preparation:
            startPreparation()
        }
    }

    func pause() {
        print("ä¸€æ™‚åœæ­¢")
        timerMode = .pausing
        delegate?.functionAllWhenStartTimerMode()
        timer.invalidate()
    }

    func reset() {
        trainigMode = .preparation
        timerMode = .notRunning
        delegate?.functionAllWhenStartTimerMode()
        timer.invalidate()
        resetInitValue()
        delegate?.functionWhenReset()
    }
    ---
    çœç•¥
    ---
}

protocol CountDownTimerDelegate {
    func functionAllStart()

    func functionTraningStart()
    func functionTraningInterval()
    func functionTraningWhenTheValueReachesZero()

    ---
    çœç•¥
    ---
    
    func functionAllWhenStartTimerMode()
    func functionWhenReset()
    func functionWhenTimerEnds()
    func functionWhenAllInterval()
    func functionWhenAllThreeSecondsAgo()
}
```
:::

## ä»¥ä¸‹ã¯å…¨ã¦SwiftUIã§ä½œæˆ

### èª­ã¿ä¸Šã’

ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒç”¨æ„ã•ã‚Œã¦ã„ã‚‹èª­ã¿ä¸Šã’ã‚¢ãƒ—ãƒª
https://apps.apple.com/jp/app/%E8%AA%AD%E3%81%BF%E4%B8%8A%E3%81%92/id6446442219

![](https://storage.googleapis.com/zenn-user-upload/bf69b03a43ad-20230514.gif =200x)

CSVãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆ(CSVã‹ã‚‰ãƒ‡ã‚³ãƒ¼ãƒ‰ï¼‹staticãƒ¡ã‚½ãƒƒãƒ‰ã§ç®¡ç†)
::: details ã€€ä¾‹

CSVãƒ‡ãƒ¼ã‚¿ä¸€è¦§

![](https://storage.googleapis.com/zenn-user-upload/12dd9f898ef7-20230515.png)

```swift

struct CSV {
    private static let allFileName: [String] = Array(1...22).map { String($0) }
    private static var countCalledConvertMethod = 0
    private static func callCSVDataText(fileName: String) -> String {
        var csvString: String = ""
            if let path = Bundle.main.path(forResource: fileName, ofType: "csv") {
                do {
                    csvString = try String(contentsOfFile: path, encoding: .utf8)
                } catch {
                    print("Error reading CSV file: \(error)")
                }
            } else {
                print("Error finding CSV file")
            }
        return csvString
    }

    private static func convertCSVDataToDictionary(_ csvData: String) -> [String: [String]] {
        var dictionary: [String: [String]] = [:]

        let rows = csvData.components(separatedBy: .newlines)

            if let key = rows.first {
                let values = Array(rows.dropFirst())
                countCalledConvertMethod += 1
                let renamedKey = String(countCalledConvertMethod) + "." + key
                dictionary[renamedKey] = values
            }

        return dictionary
    }

    static func convertAllCSVDateToDictionary() -> [String: [String]] {
        var dictionary: [String: [String]] = [:]
        allFileName.forEach { fileName in
            let csvText = callCSVDataText(fileName: fileName)
            let csvfileDictonary = convertCSVDataToDictionary(csvText)
            dictionary.merge(csvfileDictonary) { (_, new) in new }
        }
        return dictionary
    }
}
```
:::

- `ScrollView`ã‚’ç”¨ã„ãŸã‚¿ã‚°ã®ã‚¿ã‚¤ãƒˆãƒ«è¡¨ç¤º
- `List`ã‚’ç”¨ã„ãŸãƒªã‚¹ãƒˆè¡¨ç¤º
- `@AppStorage`,`@State`, `@Environment`,`@FocusState`ã‚’ç”¨ã„ãŸå®Ÿè£…
- ãƒãƒŠãƒ¼åºƒå‘ŠãŒSwiftUIã«å¯¾å¿œã—ã¦ã„ãªã„ãŸã‚ã€SwiftUIä¸Šã§UIKitã®å®Ÿè£…ï¼ˆ`UIViewRepresentable`ã‚’ç”¨ã„ã¦ï¼‰
- ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œã€æ–‡å­—ã‚µã‚¤ã‚ºå¤‰æ›´
- `.onTapGesture`,`.onReceive`,`.onPreferenceChange`,`.onAppear`ã€€ãªã©ã®modifierã‚’ç”¨ã„ãŸå®Ÿè£…

### ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ã‚¿ã‚¤ãƒãƒ¼

https://apps.apple.com/jp/app/%E3%83%9D%E3%83%A2%E3%83%89%E3%83%BC%E3%83%AD%E3%82%BF%E3%82%A4%E3%83%9E%E3%83%BC/id6447015140

ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ã‚¿ã‚¤ãƒãƒ¼ã‚’å®Ÿè£…ã—ãŸã‚¢ãƒ—ãƒª
ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªãƒ„ãƒ¼ãƒ«

![](https://storage.googleapis.com/zenn-user-upload/3b9261cc01a5-20230514.gif =200x)

- ãƒ­ãƒƒã‚¯ç”»é¢ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã®å®Ÿè£…
- ãƒ­ãƒ¼ã‚«ãƒ«é€šçŸ¥ã®å®Ÿè£…
  
::: details ã€€ä¾‹

```swift
  static private func makeNotification(afterTime: Int,timerMode: TimerMode) {
        let notificationIdentifier = "\(UUID())"
        let notificationDate = Date().addingTimeInterval(TimeInterval(afterTime))
        let dateComp = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second], from: notificationDate)

        let trigger = UNCalendarNotificationTrigger(dateMatching: dateComp, repeats: false)

        let content = UNMutableNotificationContent()
        switch timerMode {

        case .work:
            content.title = NSLocalizedString("workStart", comment: "")
        case .rest:
            content.title = NSLocalizedString("breakStart", comment: "")
        }
        content.sound = UNNotificationSound.default

        let request = UNNotificationRequest(identifier: notificationIdentifier, content: content, trigger: trigger)

        UNUserNotificationCenter.current().add(request, withCompletionHandler: nil)
    }
    static func remove() {
        let center = UNUserNotificationCenter.current()
        center.removeAllPendingNotificationRequests()
    }
```
:::

- Timerã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’å…¥ã‚ŒãŸTimerManagerã®ä½œæˆ(ObservableObject,@Publishedã€€ã‚’ç”¨ã„ã¦)
  
::: details ã€€ä¾‹

```swift
enum TimerState {
    case stopped, running, paused
}
enum TimerMode: String, CaseIterable ,Identifiable {
    case work = "ä½œæ¥­"
    case rest = "ä¼‘æ†©"

    var id: String { self.rawValue }
}
class TimerManager: ObservableObject {
    @Published var timerMode: TimerMode = .work
    @Published var timerState: TimerState = .stopped
    @Published var progress: Double = 1.0
    @Published var setCount = 0

    @AppStorage("workTimeIndex") var workTimeIndex = 2 {
        willSet {
            remainingTime = workTimes[newValue]
        }
    }
    @AppStorage("breakTimeIndex") var breakTimeIndex = 0 {
        willSet {
            remainingTime = breakTimes[newValue]
        }
    }
    @Published var timer: Timer?
    @Published var remainingTime: TimeInterval = 25 * 60

    let workTimes: [TimeInterval] = [5 * 60, 10 * 60, 25 * 60, 45 * 60,60 * 60]
    let breakTimes: [TimeInterval] = [5 * 60, 10 * 60, 15 * 60]

    var startTime: Date?
    var pauseTime: Date?

    private var elapsedTimeFromStart: TimeInterval {
        if let startTime = startTime {
           let resultElapsedTime = Date().timeIntervalSince(startTime)
            return resultElapsedTime
        } else {
            return 0
        }
    }

    init() {
        remainingTime = workTimes[workTimeIndex]
    }

    func start(workTimeIndex: Int, breakTimeIndex: Int) {
        startTime = Date()
        timerState = .running
        timerMode = .work
        initWorkTime(workTimeIndex: workTimeIndex)
        initBreakTime(breakTimeIndex: breakTimeIndex)
        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            self.timerMode = self.timerModeRelativeToElapsedTime()
            self.setCount = self.timerSetsRelativeElapsedTime()
            self.remainingTime = self.floorTimeInterval(self.elapsedTimeFromEachTimerMode())
            self.progress = self.remainingTime / self.totalTimeByTimerMode
        }
    }

    func floorTimeInterval(_ timeInterval: TimeInterval) -> TimeInterval {
        return TimeInterval(Int(timeInterval))
    }

    func pause() {
        timerState = .paused
        pauseTime = Date()
        timer?.invalidate()
        timer = nil
    }

    func resume() {
        timerState = .running
        let timeThatTheTimerHasAlreadyElapsed = startTime?.timeIntervalSince(pauseTime!)
        startTime = Date().addingTimeInterval(timeThatTheTimerHasAlreadyElapsed!)
        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            self.timerMode = self.timerModeRelativeToElapsedTime()
            self.setCount = self.timerSetsRelativeElapsedTime()
            self.remainingTime = self.floorTimeInterval(self.elapsedTimeFromEachTimerMode())
            self.progress = self.remainingTime / self.totalTimeByTimerMode
        }
    }
    func reset() {
        timer?.invalidate()
        timer = nil
        setCount = 0
        timerState = .stopped
        timerMode = .work
        initWorkTime(workTimeIndex: workTimeIndex)
    }

    func initWorkTime(workTimeIndex: Int) {
        self.workTimeIndex = workTimeIndex
        remainingTime = totalTimeByTimerMode
        progress = 1.0
    }

    func initBreakTime(breakTimeIndex: Int) {
        self.breakTimeIndex = breakTimeIndex
        remainingTime = totalTimeByTimerMode
        progress = 1.0
    }

    var totalTimeByTimerMode: TimeInterval {
        switch timerMode {
        case .work:
            return workTimes[workTimeIndex]
        case .rest:
            return breakTimes[breakTimeIndex]
        }
    }

    func timerModeRelativeToElapsedTime() -> TimerMode {
        let workTime = workTimes[workTimeIndex]
        let breakTime = breakTimes[breakTimeIndex]
        let totalTime = workTime + breakTime
        let remainder = Int(elapsedTimeFromStart) % Int(totalTime)
        if remainder < Int(workTime) {
            return .work
        } else if Int(workTime) <= remainder {
            return .rest
        }
        fatalError()
    }
    func timerSetsRelativeElapsedTime() -> Int {
        let workTime = workTimes[workTimeIndex]
        let breakTime = breakTimes[breakTimeIndex]
        let totalTime = workTime + breakTime
        let set = Int(elapsedTimeFromStart) / Int(totalTime)
        return set
    }

    func elapsedTimeFromEachTimerMode() -> TimeInterval {
        let workTime = workTimes[workTimeIndex]
        let breakTime = breakTimes[breakTimeIndex]
        let totalTime = workTime + breakTime
        let remainder = Int(elapsedTimeFromStart) % Int(totalTime)
        if remainder < Int(workTime) {
            return workTime - TimeInterval(remainder)
        } else if Int(workTime) <= remainder {
            let result = remainder - Int(workTime)
            return breakTime - TimeInterval(result)
        }
        fatalError()
    }
}

```
:::

-Viewã‚’ComponentåŒ–ã—ã¦ã€å®Ÿè£…(Viewãƒ»@Bindingã‚’ç”¨ã„ã¦)

::: details ã€€ä¾‹ã€€ProgressViewã‚’ç”¨ã„ã¦

```swift
struct CircularProgressView: View {
    @Binding var timeLeft: TimeInterval
    @Binding var progress: Double
    @Binding var setCount: Int

    let totalTime: TimeInterval
    var color: Color

    let timeFormatter: DateComponentsFormatter = {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.minute, .second]
        formatter.zeroFormattingBehavior = .pad
        return formatter
    }()

    init(timeLeft: Binding<TimeInterval>,progress: Binding<Double>,setCount: Binding<Int>,color: Color) {

        self._timeLeft = timeLeft
        self.totalTime = timeLeft.wrappedValue
        self.color = color
        self._progress = progress
        self._setCount = setCount
    }

    var body: some View {
        ZStack {
            Circle()
                .stroke(lineWidth: 20)
                .opacity(0.3)
                .foregroundColor(.gray)
            Circle()
                .trim(from: 0.0, to: CGFloat(min(progress, 1.0)))
                .stroke(style: StrokeStyle(lineWidth: 20, lineCap: .round, lineJoin: .round))
                .foregroundColor(color)
                .rotationEffect(Angle(degrees: 270.0))
                .animation(.linear, value: progress)
            VStack{
                Text(timeFormatter.string(from: timeLeft) ?? "")
                    .font(Font(UIFont.monospacedDigitSystemFont(ofSize: 80, weight: .regular)))
                    .fontWeight(.bold)
                    .minimumScaleFactor(0.5)
                    .frame(maxWidth: .infinity)
                    .fixedSize(horizontal: true, vertical: false)
                Text("\(setCount)" + NSLocalizedString("set", comment: ""))
            }
        }
    }
}

struct CircularProgressView_Previews: PreviewProvider {
    static var previews: some View {
        CircularProgressView(
            timeLeft: .constant(25 * 60),
            progress: .constant(1.0),
            setCount: .constant(1),
            color: Color.init("ThemeColor")
            )
    }
}

```
:::

### èª­ã¿ä¸Šã’ã€€ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³

https://apps.apple.com/jp/app/%E8%AA%AD%E3%81%BF%E4%B8%8A%E3%81%92-%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%83%80%E3%82%A6%E3%83%B3/id6447489589

éŸ³å£°ã§ã‚«ã‚¦ãƒ³ãƒˆã—ãŸã„ã¨ãã«ç”¨ã„ã‚‹ã‚¢ãƒ—ãƒª
é‹å‹•æ™‚ã«ä½¿ç”¨ã™ã‚‹ã¨ä¾¿åˆ©ã§ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/7ab92e3bf50d-20230514.gif =200x)

- `AVSpeechSynthesizerDelegate`ã‚’ç”¨ã„ãŸSwiftUIã§ã®ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã®å®Ÿè£…
- ViewModelã‚’ç”¨ã„ãŸå®Ÿè£…

### ãƒªã‚ºãƒ é‹å‹•ã€€ï¼ˆWatchOSï¼‰

éŸ³å£°ã§ã‚«ã‚¦ãƒ³ãƒˆã—ãŸã„ã¨ãã«ç”¨ã„ã‚‹WatchOSå¯¾å¿œã‚¢ãƒ—ãƒª

https://apps.apple.com/jp/app/id6466854178

### ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ã‚¿ã‚¤ãƒãƒ¼ã€€ï¼ˆWatchOSï¼‰

ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ã‚¿ã‚¤ãƒãƒ¼å°‚ç”¨ã®WatchOSå¯¾å¿œã‚¢ãƒ—ãƒª

https://apps.apple.com/jp/app/id6466736728

## æ–‡å­—èªè­˜ã‚¢ãƒ—ãƒª

ä¿å­˜ã—ã¦ã„ã‚‹å†™çœŸãƒ»æ’®å½±ã—ãŸå†™çœŸã‚’ä½¿ç”¨ã—ã¦ã€ç”»åƒã®æ–‡å­—èªè­˜ã§æ–‡å­—å‡ºåŠ›ã™ã‚‹ã‚¢ãƒ—ãƒª

https://apps.apple.com/jp/app/id6473706737

- Visionãƒ»VisionKitã‚’ç”¨ã„ãŸæ–‡å­—èªè­˜æ©Ÿèƒ½

## ç”»åƒç”ŸæˆAI

ç”»åƒç”ŸæˆAIã®APIã‚’ç”¨ã„ã¦ã‚¢ãƒ—ãƒª

https://apps.apple.com/jp/app/id6479509633

- `String Catalog`ã‚’ç”¨ã„ãŸãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºå¯¾å¿œ
- [StabilityAI REST APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://platform.stability.ai/docs/api-reference)ã‚’å‚è€ƒã«APIClientã®å®Ÿè£…
- `SwiftData`ã‚’ç”¨ã„ãŸãƒ‡ãƒ¼ã‚¿ç®¡ç†
  
## ç™ºä¿¡æ´»å‹•

ç™ºä¿¡æ´»å‹•ã¯Zennãƒ»Qiitaã§è¡Œã£ã¦ã„ã¾ã™ã€‚
ç¾åœ¨ã¯Zennã‚’ä¸­å¿ƒã«ç™ºä¿¡ã—ã¦ã„ã¾ã™ã€‚

### Zenn

https://zenn.dev/muranaka

ç›´è¿‘ã§ã‚ã‚Œã°ã€HealthKitãƒ»SwiftDataé–¢é€£ã®ç™ºä¿¡ã‚’ã—ã¾ã—ãŸã€‚

### Qiita

https://qiita.com/muranakar

ç›´è¿‘ã§ã‚ã‚Œã°ã€æ¥­å‹™ã§ç”¨ã„ã‚‹ReactNativeã®ç™ºä¿¡ã‚’ã—ã¾ã—ãŸã€‚

## æœ€å¾Œã«

æ²¢å±±ã®æŠ€è¡“ã«è§¦ã‚Œã‚‹ã“ã¨ãŒã§ãã€ä¸€ã¤ä¸€ã¤è‹¦åŠ´ã—ãŸã“ã¨ã‚‚è‰¯ã„æ€ã„å‡ºã§ã™ã€‚
ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªã‚’è¨˜è¼‰ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ã“ã®è¨˜äº‹ã‚’æ›¸ãã¾ã—ãŸã€‚

è‰¯ã‹ã£ãŸã¨æ€ã£ãŸã‚‰ã€ã„ã„ã­ã‚„Twitterã®ãƒ•ã‚©ãƒ­ãƒ¼ã‚ˆã‚ã—ããŠé¡˜ã„ã„ãŸã—ã¾ã™ã€‚

https://sites.google.com/view/muranakar

å€‹äººã§ã‚¢ãƒ—ãƒªã‚’ä½œæˆã—ã¦ã„ã‚‹ã®ã§ã€è‰¯ã‹ã£ãŸã‚‰è¦—ã„ã¦ã¿ã¦ãã ã•ã„ã€‚