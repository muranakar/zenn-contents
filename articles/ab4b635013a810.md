---
title: "＝＝＝＝＝＝＝＝＝【Flutter】BLoCパターンを使用したTodoアプリの実装 with SQLite"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Flutter, Dart, SQlite]
published: false
---

# BLoC パターンを使用した Todo アプリの実装

## アプリケーションの概要

この Todo アプリでは、BLoC パターンを使用してデータフローを管理し、SQLite でローカルデータを永続化します。
CRUD 機能を実装するのみとします。

## プロジェクトの構成

まず必要なパッケージを`pubspec.yaml`に追加します:

```yaml
dependencies:
  sqflite: ^2.3.0 # SQLiteデータベース用
  path_provider: ^2.1.1 # ファイルパス取得用
```

### ディレクトリ構成

```
lib/
  ├── bloc/
  │   └── todo_bloc.dart
  ├── dao/
  │   └── todo_dao.dart
  ├── database/
  │   └── database.dart
  ├── model/
  │   └── todo.dart
  ├── repository/
  │   └── todo_repository.dart
  └── ui/
      └── home_page.dart
```

## データモデルの実装

まず`Todo`モデルクラスを作成します:

```dart
// lib/model/todo.dart

class Todo {
  int id;
  String description;
  bool isDone;

  // コンストラクタ - isDoneはデフォルトでfalse
  Todo({
    this.id,
    this.description,
    this.isDone = false
  });

  // JSONからTodoオブジェクトを生成するファクトリメソッド
  factory Todo.fromDatabaseJson(Map<String, dynamic> data) => Todo(
    id: data['id'],
    description: data['description'],
    // SQLiteにはboolean型がないため、0/1で管理
    isDone: data['is_done'] == 0 ? false : true,
  );

  // TodoオブジェクトをJSONに変換するメソッド
  Map<String, dynamic> toDatabaseJson() => {
    "id": this.id,
    "description": this.description,
    "is_done": this.isDone == false ? 0 : 1,
  };
}
```

## データベースの実装

SQLite データベースを管理するクラスを作成します:

```dart
// lib/database/database.dart

import 'dart:async';
import 'dart:io';
import 'package:path/path.dart';
import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';

class DatabaseProvider {
  static final DatabaseProvider dbProvider = DatabaseProvider();
  Database _database;

  // データベースのシングルトンインスタンスを取得
  Future<Database> get database async {
    if (_database != null) return _database;
    _database = await createDatabase();
    return _database;
  }

  // データベースの作成
  createDatabase() async {
    // アプリのドキュメントディレクトリを取得
    Directory documentsDirectory = await getApplicationDocumentsDirectory();
    String path = join(documentsDirectory.path, "TodoApp.db");

    var database = await openDatabase(
      path,
      version: 1,
      onCreate: initDB,
      onUpgrade: onUpgrade
    );
    return database;
  }

  // テーブルの作成
  void initDB(Database database, int version) async {
    await database.execute("""
      CREATE TABLE Todo (
        id INTEGER PRIMARY KEY,
        description TEXT,
        is_done INTEGER
      )
    """);
  }

  // データベースの更新時の処理
  void onUpgrade(Database database, int oldVersion, int newVersion) {
    if (newVersion > oldVersion) {
      // マイグレーション処理を記述
    }
  }
}
```

## データアクセスレイヤーの実装

Todo の CRUD 操作を行う DAO クラスを実装します:

```dart
// lib/dao/todo_dao.dart

import 'dart:async';
import '../database/database.dart';
import '../model/todo.dart';

class TodoDao {
  final dbProvider = DatabaseProvider.dbProvider;

  // Todo作成
  Future<int> createTodo(Todo todo) async {
    final db = await dbProvider.database;
    var result = db.insert('Todo', todo.toDatabaseJson());
    return result;
  }

  // Todo一覧取得
  Future<List<Todo>> getTodos({List<String> columns, String query}) async {
    final db = await dbProvider.database;

    List<Map<String, dynamic>> result;
    if (query != null && query.isNotEmpty) {
      result = await db.query('Todo',
        columns: columns,
        where: 'description LIKE ?',
        whereArgs: ["%$query%"]
      );
    } else {
      result = await db.query('Todo', columns: columns);
    }

    List<Todo> todos = result.isNotEmpty
      ? result.map((item) => Todo.fromDatabaseJson(item)).toList()
      : [];
    return todos;
  }

  // Todo更新
  Future<int> updateTodo(Todo todo) async {
    final db = await dbProvider.database;
    var result = await db.update('Todo', todo.toDatabaseJson(),
      where: "id = ?",
      whereArgs: [todo.id]
    );
    return result;
  }

  // Todo削除
  Future<int> deleteTodo(int id) async {
    final db = await dbProvider.database;
    var result = await db.delete('Todo',
      where: 'id = ?',
      whereArgs: [id]
    );
    return result;
  }
}
```

## リポジトリレイヤーの実装

TodoRepository はデータソースの抽象化を行います:

```dart
// lib/repository/todo_repository.dart

import '../dao/todo_dao.dart';
import '../model/todo.dart';

class TodoRepository {
  final todoDao = TodoDao();

  Future getAllTodos({String query}) => todoDao.getTodos(query: query);

  Future insertTodo(Todo todo) => todoDao.createTodo(todo);

  Future updateTodo(Todo todo) => todoDao.updateTodo(todo);

  Future deleteTodoById(int id) => todoDao.deleteTodo(id);
}
```

## BLoC の実装

TodoBLoC はビジネスロジックとデータの流れを管理します:

```dart
// lib/bloc/todo_bloc.dart

import 'dart:async';
import '../model/todo.dart';
import '../repository/todo_repository.dart';

class TodoBloc {
  final _todoRepository = TodoRepository();

  // StreamControllerでTodoリストのストリームを管理
  final _todoController = StreamController<List<Todo>>.broadcast();

  // Todoリストを取得するためのストリーム
  Stream<List<Todo>> get todos => _todoController.stream;

  TodoBloc() {
    getTodos();
  }

  // Todoリストの取得
  getTodos({String query}) async {
    _todoController.sink.add(
      await _todoRepository.getAllTodos(query: query)
    );
  }

  // 新規Todo追加
  addTodo(Todo todo) async {
    await _todoRepository.insertTodo(todo);
    getTodos();
  }

  // Todo更新
  updateTodo(Todo todo) async {
    await _todoRepository.updateTodo(todo);
    getTodos();
  }

  // Todo削除
  deleteTodoById(int id) async {
    await _todoRepository.deleteTodoById(id);
    getTodos();
  }

  // リソース解放
  dispose() {
    _todoController.close();
  }
}
```

## UI の実装

最後に UI を実装します。StreamBuilder を使用して Todo リストを表示します:

```dart
// lib/ui/home_page.dart

import 'package:flutter/material.dart';
import '../bloc/todo_bloc.dart';
import '../model/todo.dart';

class HomePage extends StatelessWidget {
  final TodoBloc todoBloc = TodoBloc();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Todo App')),
      body: StreamBuilder<List<Todo>>(
        stream: todoBloc.todos,
        builder: (context, snapshot) {
          if (snapshot.hasData) {
            return ListView.builder(
              itemCount: snapshot.data.length,
              itemBuilder: (context, index) {
                Todo todo = snapshot.data[index];
                return Dismissible(
                  key: Key(todo.id.toString()),
                  onDismissed: (direction) {
                    todoBloc.deleteTodoById(todo.id);
                  },
                  child: ListTile(
                    title: Text(todo.description),
                    leading: Checkbox(
                      value: todo.isDone,
                      onChanged: (bool value) {
                        todo.isDone = value;
                        todoBloc.updateTodo(todo);
                      },
                    ),
                  ),
                );
              },
            );
          }
          return Center(child: CircularProgressIndicator());
        },
      ),
      floatingActionButton: FloatingActionButton(
        child: Icon(Icons.add),
        onPressed: () {
          // Todo追加画面への遷移処理
        },
      ),
    );
  }
}
```

## まとめ

BLoC パターンを使用することで、以下のメリットが得られます:

- ビジネスロジックと UI の分離
- コードの再利用性の向上
- テストの容易さ
- 状態管理の一元化

このアプリケーションでは、Stream と StreamController を使用してデータの流れを管理し、SQLite でデータを永続化しています。各レイヤー(Model、DAO、Repository、BLoC)が明確な責務を持ち、保守性の高いコードとなっています。

## 参照

https://vaygeth.medium.com/reactive-flutter-todo-app-using-bloc-design-pattern-b71e2434f692
